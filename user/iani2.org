* Documentation: List of packages used

This is an (incomplete) list of the packages used in this configuration.
Mostly use command package-install, or list-packages to install these.
Some of these have been downloaded manually and put in packages folder.

Some of the packages configurations (for example: wanderlust) have not yet been moved to the present file.

** Generic packages for overall Emacs configuration

- ido-mode :: Basic enhancement of autocomplete for minibuffer.
              But also autocompletion when coding.
- icicles :: More powerful enhancement of autocomplete in all sorts of situations.
             See: http://www.emacswiki.org/emacs/EmacsNewbieWithIcicles

Note: ido-mode and icicles are mutually compatible and can be on at the same time.
Icicles can be switched on and off with M-x icy-mode.

- bookmark+ :: Bookmark enhancement.
- smex :: Enhancement of autocomplete for commands in minibuffer.
- solarized-dark :: Additional emacs color theme.
- lacarte :: execute menu commands from the keyboard
- dired+ :: Enhancement of dired.

- windmove :: move cursor between windows (using function-shift-cursor keys)
- switch-window :: When more than 2 windows, then select window by number, showing window number in large font overlay.
- buffer-move :: Switch buffer positions in windows (using function-control-cursor keys)

** Packages for specific authoring modes (emacs-lisp, SuperCollider etc.)

*** Generic authoring/editing packages
- paredit :: Paredit mode.
- rainbow-delimiters-mode :: Multi-color parentheses, brackets, braces.
- hl-sexp-mode (alternative: highlight-sexps-mode) :: highight regions enclosed in parentheses, brackets, braces
- multiple-cursors :: Magnar Sveen's multiple cursor package.
- key-chord :: Trigger a command or keyboard macro by typing two characters in quick succession or together.
- AceJump :: Jump to any one of displayed characters/words/lines starting with a character typed (triggered by key-chord combinations).
- whitespace mode :: mark unnecessary white space and long lines (disabled in org-mode).
- yasnippets :: Expand keywords into code snippets.
- auto-complete :: Provide auto-completion with popup window

*** Emacs-lisp

- ElDoc :: Show arguments required by current function in minibuffer.

*** Org-mode

- org :: Org-mode.
- epresent :: Present slides directly from org-mode.
- calfw :: Present org-mode agenda in calendar-style day, week and month views.
- collector :: Collect property data into org-mode table.
- org-bibedit :: Bibtex integration for orgmode.
- ox-latex :: Latex support
- org-crypt :: Encrypt org-mode entries tagged with =crypt=
- ox-reveal :: Export org-mode files as reveal.js slide presentations.
- org-drill, flashcard, flashcard-sm5 :: Flashcard memorization drill software for org-mode.

*** SuperCollider

- sclang :: SuperCollider.
- sclang-ac-mode :: auto-complete mode for SuperCollider.
- sclang-snippets :: yasnippets for SuperCollider.

Not used, because it seems to interfere with sclang-ac-mode:

- sclang-extensions :: Context sensitive moving and evaluation in SuperCollide

*** ChucK

- chuck :: chuck-mode.

** Other extensions: Email, shells etc.
*** Wanderlust: Email client for emacs

- wanderlust :: Email-client for emacs.
- bbdb-hooks :: Needed for wanderlust.
- bbdb-wl :: Neeed for wanderlust.

* Generic Emacs Customization

** Theme: solarized-dark
#+BEGIN_SRC emacs-lisp
  (load-theme 'solarized-dark)
#+END_SRC
** Internationalization: Set mac-native fonts for japanese/greek
:PROPERTIES:
:DATE:     <2013-12-08 Sun 15:12>
:END:

Here is a solution that works fine for displaying Latin, Greek and Japanese texts in the same buffer.  The Menlo font displays Greek clearly and smoothly, and since it is a mono-space font, it also works well in tables.  The two lisp expressions have to be evaluated in the following order for this to work.

#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default"
                  'japanese-jisx0208
                  '("Hiragino Mincho Pro" . "iso10646-1"))
(set-fontset-font "fontset-default"
                  'greek
 ;; Note: iso10646-1 = Universal Character set (UCS)
 ;; It is compatible to Unicode, in its basic range
                  '("Menlo" . "iso10646-1"))
#+END_SRC

Links for further reading:

http://sunsite.univie.ac.at/textbooks/emacs/emacs_22.html#SEC203
http://www.gnu.org/software/emacs/manual/html_node/emacs/Modifying-Fontsets.html
For Greek see: http://iris.math.aegean.gr/~atsol/emacs-unicode/

** Maximize/toggle frame
#+BEGIN_SRC emacs-lisp
(maximize-frame) ;; maximize frame on startup
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
(tool-bar-mode -1)
#+END_SRC

** Generic Packages

*** desktop

Save desktop between sessions.  To clear desktop: M-x desktop-clear

#+begin_src emacs-lisp :tangle yes
(desktop-save-mode 1)
#+end_src

*** bookmark+, ido-mode, imenu(+), auto-complete, yasnippets, icicles

#+BEGIN_SRC emacs-lisp
  (require 'bookmark+)
  (require 'ido)
  (require 'imenu+)
  (require 'auto-complete)
  (ido-mode t)
  (icicle-mode)
  ;; (yas-global-mode)
#+END_SRC

*** Switch window

#+BEGIN_SRC emacs-lisp
  (require 'switch-window)
  (global-set-key (kbd "C-x o") 'switch-window)
#+END_SRC

*** Buffer-move, windmove, buffer switching

- windmove (package) :: Use cursor keys to switch cursor position between windows.  Bound to control-super-<cursor key>.
- buffer-move (package) :: Use cursor keys to switch buffer position between windows.  Bound to fn-shift-<cursor key>.
- next-buffer, previous-buffer (built-in commands) :: Use cursor keys to switch to previous/next buffer in same window.  Bound to function-super-<cursor key>

#+BEGIN_SRC emacs-lisp
  (require 'windmove)
  (global-set-key (kbd "<C-s-up>") 'windmove-up)
  (global-set-key (kbd "<C-s-down>") 'windmove-down)
  (global-set-key (kbd "<C-s-right>") 'windmove-right)
  (global-set-key (kbd "<C-s-left>") 'windmove-left)

  (require 'buffer-move)
  (global-set-key (kbd "<S-prior>") 'buf-move-up)
  (global-set-key (kbd "<S-next>") 'buf-move-down)
  (global-set-key (kbd "<S-end>") 'buf-move-right)
  (global-set-key (kbd "<S-home>") 'buf-move-left)

  (global-set-key (kbd "<s-home>") 'previous-buffer)
  (global-set-key (kbd "<s-end>") 'next-buffer)
#+END_SRC

*** Note on icicle key bindings and org-mode

C-c ' in org mode runs the command org-edit-special, for editing babel commands and other blocks.  To avoid conflict with icicles binding of the same key to icicle-occur, remap the latter to something else (e.g. C-c C-M-'), like this:
1. type M-x customize-group <RET> Icicles-Key-Bindings <RET>
2. Scroll down to Icicle Top Level Key Bindings, open the list, find icicle-occur, enter C-c C-M-' to the =Key:= field, go to top of buffer, use the =State= button to save this.

See also discussion here: http://www.emacswiki.org/emacs/Icicles_-_Key_Binding_Discussion
The relevant part is cited below:

#+BEGIN_QUOTE
But what is the best way to remove an internal value in the option `icicle-top-level-key-bindingsâ€™? It is a quite big list in its value. If I choose to remove that specific line through customize that variable, it would make my init file un-readable. So I need to write some function to make it in the runtime. Here is my function:
#+END_QUOTE

#+BEGIN_SRC elisp
  (eval-after-load "icicles-opt.el"
    (add-hook
     'icicle-mode-hook
     (lambda ()
       (setq my-icicle-top-level-key-bindings
             (mapcar (lambda (lst)
                       (unless (string= "icicle-occur" (nth 1 lst)) lst))
                     icicle-top-level-key-bindings))
       (setq icicle-top-level-key-bindings my-icicle-top-level-key-bindings) )))

;;  (icy-mode)
#+END_SRC

#+BEGIN_QUOTE
DavidYoung
#+END_QUOTE

*** lacarte: select menu items from the keyboard (good for org-mode with imenu)

#+BEGIN_SRC emacs-lisp
(require 'lacarte)
(global-set-key [?\e ?\M-x] 'lacarte-execute-command)
#+END_SRC

*** Ido-imenu command and jump back after completion, by Magnar Sveen, and others.

Disabled.

#+BEGIN_SRC elisp
  ;;; ido-imenu
  (defun ido-imenu ()
    "Update the imenu index and then use ido to select a symbol to navigate to.
  Symbols matching the text at point are put first in the completion list."
    (interactive)
    (imenu--make-index-alist)
    (let ((name-and-pos '())
          (symbol-names '()))
      (flet ((addsymbols
            (symbol-liost)
            (when (listp symbol-list)
              (dolist (symbol symbol-list)
                (let ((name nil) (position nil))
                  (cond
                   ((and (listp symbol) (imenu--subalist-p symbol))
                    (addsymbols symbol))

                   ((listp symbol)
                    (setq name (car symbol))
                    (setq position (cdr symbol)))

                   ((stringp symbol)
                    (setq name symbol)
                    (setq position
                          (get-text-property 1 'org-imenu-marker symbol))))

                  (unless (or (null position) (null name))
                    (add-to-list 'symbol-names name)
                    (add-to-list 'name-and-pos (cons name position))))))))
        (addsymbols imenu--index-alist))
  ;; If there are matching symbols at point, put them at the beginning of `symbol-names'.
      (let ((symbol-at-point (thing-at-point 'symbol)))
        (when symbol-at-point
          (let* ((regexp (concat (regexp-quote symbol-at-point) "$"))
                 (matching-symbols
                  (delq nil (mapcar (lambda (symbol)
                                      (if (string-match regexp symbol) symbol))
                                    symbol-names))))
            (when matching-symbols
              (sort matching-symbols (lambda (a b) (> (length a) (length b))))
              (mapc
               (lambda (symbol)
                 (setq symbol-names (cons symbol (delete symbol symbol-names))))
               matching-symbols)))))
      (let* ((selected-symbol (ido-completing-read "Symbol? " symbol-names))
             (position (cdr (assoc selected-symbol name-and-pos))))
        (goto-char position))))

  ;; Push mark when using ido-imenu

  (defvar push-mark-before-goto-char nil)

  (defadvice goto-char (before push-mark-first activate)
    (when push-mark-before-goto-char
      (push-mark)))

  (defun ido-imenu-push-mark ()
    (interactive)
    (let ((push-mark-before-goto-char t))
      (ido-imenu)))
#+END_SRC

#+RESULTS:
: ido-imenu-push-mark

*** smex (auto-complete minibuffer commands called with Meta-x)

#+BEGIN_SRC emacs-lisp
;; Smex: Autocomplete meta-x command
(global-set-key [(meta x)]
                (lambda ()
                  (interactive)
                  (or (boundp 'smex-cache)
                      (smex-initialize))
                  (global-set-key [(meta x)] 'smex)
                  (smex)))

(global-set-key [(shift meta x)]
                (lambda ()
                  (interactive)
                  (or (boundp 'smex-cache)
                      (smex-initialize))
                  (global-set-key [(shift meta x)] 'smex-major-mode-commands)
                  (smex-major-mode-commands)))
#+END_SRC

*** Multiple Cursors

#+BEGIN_SRC emacs-lisp
(require 'multiple-cursors)
(global-set-key (kbd "C-c m") 'helm-mini)
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
#+END_SRC

*** Whitespace Mode

#+BEGIN_SRC emacs-lisp
  (defun turn-off-whitespace-mode () (whitespace-mode -1))
  (defun turn-on-whitespace-mode () (whitespace-mode 1))
#+END_SRC

*** Key Chords

#+BEGIN_SRC emacs-lisp
  (require 'key-chord)
  (key-chord-mode 1)

  (defun paren-sexp ()
    (interactive)
    (insert "(")
    (forward-sexp)
    (insert ")"))

  (defun code-quote-sexp ()
    (interactive)
    (insert "=")
    (forward-sexp)
    (insert "="))

  (key-chord-define-global "jk"     'ace-jump-char-mode)
  (key-chord-define-global "jj"     'ace-jump-word-mode)
  (key-chord-define-global "jl"     'ace-jump-line-mode)

  (key-chord-define-global "hj"     'undo)

  (key-chord-define-global "{}"     "{   }\C-b\C-b\C-b")
  (key-chord-define-global "()"     'paren-sexp)
  (key-chord-define-global "(_"     "()\C-b")
  (key-chord-define-global "=="     'code-quote-sexp)

  ;; Exit auto-complete, keeping the current selection,
  ;; while avoiding possible side-effects of TAB or RETURN.
  (key-chord-define-global "KK"      "\C-f\C-b")
  ;; Trick for triggering yasnippet when using in tandem with auto-complete:
  ;; Move forward once to get out of auto-complete, then backward once to
  ;; end of keyword, and enter tab to trigger yasnippet.
  (key-chord-define-global "KL"      "\C-f\C-b\C-i")

  ;; Jump to any symbol in buffer using ido-imenu
  (key-chord-define-global "KJ"      'ido-imenu)
#+END_SRC

*** hl-sexp mode (also: highlight-sexps)

Highlight expressions enclosed by (), {} or [] in code.

There exist 2 versions:

1. hl-sexp package available from elpa.
   Package name: hl-sexp
   Mode name: hl-sexp-mode
2. highlight-sexps.el, from http://www.emacswiki.org/emacs/HighlightSexp.
   Package name: highlight-sexps
   Mode name: highlight-sexps-mode

highlight-sexps.el looks nicer, because it highlights both the innermost s-expression and the one enclosing it, and it does not un-highlight the line where the cursor is on.  But it sometimes stops working.  So I use hl-sexp

#+BEGIN_SRC emacslisp
  (require 'hl-sexp)
  ;; (require 'highlight-sexps)
  ;; Include color customization for dark color theme here.
  (custom-set-variables
   '(hl-sexp-background-colors (quote ("gray0"  "#0f003f"))))
#+END_SRC

*** NEEDS_REVIEW Dired extensions and customization
**** Dired+

#+BEGIN_SRC emacs-lisp
(require 'dired+)
#+END_SRC

**** Dired customization from Healy's startup kit
(From Healy's startup kit)

Note: Perhaps these are not used.  Need to test.

***** Open pdf files with default macos app in dired
:PROPERTIES:
:DATE:     <2013-12-01 Sun 15:01>
:END:

From: http://stackoverflow.com/questions/20019732/define-keybinding-for-dired-to-run-a-command-open-on-the-file-under-the-cur

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "<SPC>")
    (lambda () (interactive)
      (let ((lawlist-filename (dired-get-file-for-visit)))
        (if (equal (file-name-extension lawlist-filename) "pdf")
            (start-process "default-pdf-app" nil "open" lawlist-filename)))))
#+END_SRC
***** Dired-x
Dired extensions
#+SOURCE: Dired-x
#+BEGIN_SRC emacs-lisp
  (load "dired-x")
#+END_SRC

#+RESULTS:
: t

***** Dired open multiple files
In dired mode, visit all marked files using. Bound to the "F" key.
#+SOURCE: dired-F
#+BEGIN_SRC emacs-lisp
  (eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "F" 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the point, or when prefix arg, the next N files "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))))
#+END_SRC

#+RESULTS:
: my-dired-find-file

***** Stripe Dired buffers
#+name: stripe-dired
#+begin_src [emacs-lisp (This part is disabled)]
(require 'stripe-buffer)
(add-hook 'org-mode-hook 'org-table-stripes-enable)
(add-hook 'dired-mode-hook 'stripe-listify-buffer)
#+end_src

*** TODO Fixme minor mode?

http://www.emacswiki.org/emacs/FixmeMode
http://www.emacswiki.org/emacs/fixme-mode.el

Or see: hl-todo, and further packages like it, listed in hl-todo Help file:

- [[http://emacswiki.org/fic-ext-mode.el][fic-ext-mode]]
- [[https://github.com/lewang/fic-mode][fic-mode]]
- [[http://emacswiki.org/FixmeMode][fixme-mode]]
- [[https://github.com/rolandwalker/fixmee][fixmee]]
- see http://emacswiki.org/FixmeMode for more alternatives

If you like this you might also like [[https://github.com/tarsius/orglink][orglink]].
*** Mac-OS extension: Open file in finder

From: http://stackoverflow.com/questions/20510333/in-emacs-how-to-show-current-file-in-finder

#+BEGIN_SRC emacs-lisp
  (defun open-finder ()
    (interactive)
    ;; IZ Dec 25, 2013 (3:25 PM): Making this work in dired:
    (if (equal major-mode 'dired-mode)
        (open-finder-dired)
        (let ((path
               (if (equal major-mode 'dired-mode)
                   (file-truename (dired-file-name-at-point))
                 (buffer-file-name)))
              dir file)
          (when path
            (setq dir (file-name-directory path))
            (setq file (file-name-nondirectory path))
            (open-finder-1 dir file)))))

  (defun open-finder-1 (dir file)
    (message "open-finder-1 dir: %s\nfile: %s" dir file)
    (let ((script
           (if file
               (concat
                "tell application \"Finder\"\n"
                " set frontmost to true\n"
                " make new Finder window to (POSIX file \"" dir "\")\n"
                " select file \"" file "\"\n"
                "end tell\n")
             (concat
              "tell application \"Finder\"\n"
              " set frontmost to true\n"
              " make new Finder window to {path to desktop folder}\n"
              "end tell\n"))))
      (start-process "osascript-getinfo" nil "osascript" "-e" script)))

#+END_SRC
* Customization of Specific Authoring Modes
** SuperCollider
*** Sclang Setup
#+BEGIN_SRC emacs-lisp
;;; Directory of SuperCollider support, for quarks, plugins, help etc.
(defvar sc_userAppSupportDir
  (expand-file-name "~/Library/Application Support/SuperCollider"))

;; Make path of sclang executable available to emacs shell load path
(add-to-list
 'exec-path
 "/Applications/SuperCollider/SuperCollider.app/Contents/Resources/")

;; Global keyboard shortcut for starting sclang
(global-set-key (kbd "C-c M-s") 'sclang-start)
;; overrides alt-meta switch command
(global-set-key (kbd "C-c W") 'sclang-switch-to-workspace)

;; Disable switching to default SuperCollider Workspace when recompiling SClang
(setq sclang-show-workspace-on-startup nil)

;; Save results of sc evaluation in elisp variable for access in emacs
(defvar sclang-return-string  nil
  "The string returned by sclang process after evaluating expressions.")

(defadvice sclang-process-filter (before provide-sclang-eval-results)
  "Pass sc eval return string to elisp by setting sclang-return-string variable."
  (setq sclang-return-string (ad-get-arg 1)))

(ad-activate 'sclang-process-filter)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'sclang)
#+END_SRC

*** SuperCollider-specific minor modes

Paredit mode breaks re-starting sclang! Therefore, do not use it. Paredit-style bracket movement commands d, u, f, b, n, p work in sclang-mode without loading Paredit.

Sclang-extensions-mode possibly breaks sclang-ac-mode.  Therefore not trying it out for now.

#+BEGIN_SRC emacs-lisp
  ;; paredit mode breaks re-starting sclang! Therefore, do not use it.
  ;; Note: Paredit-style bracket movement commands d, u, f, b, n, p work
  ;; in sclang-mode without loading Paredit.
  ;; (add-hook 'sclang-mode-hook 'paredit-mode)
  (add-hook 'sclang-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'sclang-mode-hook 'hl-sexp-mode)
  (add-hook 'sclang-mode-hook 'sclang-ac-mode)
  ;; Following possibly breaks auto-complete in my setup:  Disabled for now.
  ;; (add-hook 'sclang-mode-hook 'sclang-extensions-mode)
#+END_SRC

*** Sclang keyboard shortcuts

#+BEGIN_SRC emacs-lisp
;; Global keyboard shortcut for starting sclang
(global-set-key (kbd "C-c M-s") 'sclang-start)
;; Show workspace
(global-set-key (kbd "C-c C-M-w") 'sclang-switch-to-workspace)
#+END_SRC
** emacs-lisp
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'emacs-lisp-mode-hook 'hl-sexp-mode)
  (add-hook 'emacs-lisp-mode-hook 'hl-sexp-mode)
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-whitespace-mode)
  (add-hook 'emacs-lisp-mode-hook 'auto-complete-mode)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  #+END_SRC

** org-mode
*** Use visual line, whitespace and windmove in org-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'visual-line-mode)
  (add-hook 'org-mode-hook 'turn-off-whitespace-mode)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
#+END_SRC

*** Customize Org-mode display

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t) ;; auto-indent text in subtrees
  (setq org-hide-leading-stars t) ;; hide leading stars in subtree headings
  (setq org-src-fontify-natively t) ;; colorize source-code blocks natively
#+END_SRC

*** Calendar framework: Show org agenda in iCal-style layout

#+BEGIN_SRC emacs-lisp
 (require 'calfw)
#+END_SRC
*** Log: (simplified alternative to capture)
:PROPERTIES:
:DATE:     <2013-12-07 Sat 21:59>
:ID:       1E0A70E5-7417-48E7-B17A-9C727D995AE4
:END:

Time tasks and keep log file, in a very short way

- Very simple and fast input mechanism
- New task simply also sets the timestamp for the end of the previous one.
- Following properties are set:
  START_TIME (= active timestamp set at time of start)
  END_TIME (= active timestamp set at time of start of next log entry)
  TIME_SPAN (= START_TIME--END_TIME as timestamps)
  DURATION (= START_TIME-END_TIME as hours:minutes)
- Keeps current task in file "stopwatch.txt"
  This is read by geeklet CountUp, to display duration of current task.
  (sh code of geeklet is included below).

**** CountUp geeklet code

#+BEGIN_SRC sh
#!/bin/bash
# Homework countdown
# BETA - I will update this when I get more time
function countdown
{
	CURRENT=$(date -j -f %D_%T $1 +%s)
	TARGET=$(date +%s)
	LEFT=$((TARGET-CURRENT))
	WEEKS=$((LEFT/604800))
	DAYS=$(( (LEFT%604800)/86400))
	HOURS=$(( (LEFT%86400)/3600))
	MINS=$(( (LEFT%3600)/60))
	SECS=$((LEFT%60))

	lblWEEKS="Weeks"
	lblDAYS="Days"

	if [ $DAYS == 1 ]
	then
	lblDAYS="Day"
	fi

	if [ $WEEKS == 1 ]
	then
	lblWEEKS="Weeky"
	fi

	if [ $HOURS -lt 10 ]
	then
		HOURS=0$HOURS
	fi

	if [ $MINS -lt 10 ]
	then
		MINS=0$MINS
	fi


	if [ $SECS -lt 10 ]
	then
		SECS=0$SECS
	fi


	echo $2 $HOURS:$MINS:$SECS
	# Optional extra line between timers
	# echo
}
DATES=( $( cat /Users/iani2/Dropbox/000WORKFILES/org/monitoring/stopwatch.txt ) )
# Even numbered indices are names, odd numbered indices are dates

if [ ${#DATES[@]} == 0 ]
then
echo "No Deadlines!"
return
fi

for (( i = 0 ; i < ${#DATES[@]} ; i+=2 ))
do
countdown ${DATES[i+1]} ${DATES[i]}
done
#+END_SRC

**** Emacs-lisp log function

#+BEGIN_SRC emacs-lisp
  (defun log (topic)
    "Write countdown file for countdown geeklet.
    Ask user number of seconds to plan countdown in future."
    (interactive "MEnter task topic: ")
    (if (< (length topic) 1) (setq topic "Untitled task"))
    (let ((timer-string
           (concat
            (replace-regexp-in-string " " "_" topic)
            (format-time-string ": %D_%T" (current-time)))))
      (find-file
       "/Users/iani2/Dropbox/000WORKFILES/org/monitoring/stopwatch.txt")
      (beginning-of-buffer)
      (kill-line)
      (insert-string timer-string)
      (save-buffer)
      (message (concat "Now timing: " timer-string))
      (find-file
       "/Users/iani2/Dropbox/000WORKFILES/org/monitoring/log.org")
      (widen)
      (end-of-buffer)
      (insert-string "-")
      (org-insert-time-stamp (current-time) t)
      (beginning-of-line)
      (kill-line)
      (if (> (org-outline-level) 1) (outline-up-heading 100 t))
      (org-set-property
       "END_TIME"
       (replace-regexp-in-string
        ">" "]"
        (replace-regexp-in-string "<" "[" org-last-inserted-timestamp)))
      (org-set-property
       "TIMER_SPAN"
       (concat
        (replace-regexp-in-string
         ">" "]"
         (replace-regexp-in-string "<" "[" (org-entry-get (point) "START_TIME")))
        "--"
        (org-entry-get (point) "END_TIME")))
      (let* ((seconds
              (-
               (org-float-time
                (apply
                 'encode-time
                 (org-parse-time-string (org-entry-get (point) "END_TIME"))))
               (org-float-time
                (apply
                 'encode-time
                 (org-parse-time-string (org-entry-get (point) "START_TIME"))))
               ))
             (hours (floor (/ seconds 3600)))
             (seconds (- seconds (* 3600 hours)))
             (minutes (floor (/ seconds 60))))
        (org-set-property
         "DURATION"
         (replace-regexp-in-string " " "0" (format "%2d:%2d" hours minutes))))
      (end-of-buffer)
      (insert-string "\n* ")
      (insert-string (replace-regexp-in-string "_" " " timer-string))
      ;;      (insert-string "\n")
      (org-set-property "START_TIME" org-last-inserted-timestamp)
      (org-id-get-create)
      (org-set-tags-command)
  ;;    (if narrow-p
      (org-narrow-to-subtree)
      (goto-char (point-max))
      (org-show-subtree)
      (org-show-entry)
      (save-buffer)
  ;;    )
      ))

  (global-set-key (kbd "C-M-l") 'log)
#+END_SRC

#+RESULTS:
: log
*** Org-Babel: enable some languages

Enable some cool languages in org-babel mode.

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (sh . t)
   (ruby . t)
   (python . t)
   (perl . t)
   ))
#+END_SRC

*** Orgmode latex customization

#+BEGIN_SRC emacs-lisp
;;; Load latex package
(require 'ox-latex)

;;; Use xelatex instead of pdflatex, for support of multilingual fonts (Greek etc.)
(setq org-latex-pdf-process (list "xelatex -interaction nonstopmode -output-directory %o %f" "xelatex -interaction nonstopmode -output-directory %o %f" "xelatex -interaction nonstopmode -output-directory %o %f"))

;;; Add beamer to available latex classes, for slide-presentaton format
(add-to-list 'org-latex-classes
             '("beamer"
               "\\documentclass\[presentation\]\{beamer\}"
               ("\\section\{%s\}" . "\\section*\{%s\}")
               ("\\subsection\{%s\}" . "\\subsection*\{%s\}")
               ("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")))

;;; Add memoir class (experimental)
(add-to-list 'org-latex-classes
             '("memoir"
               "\\documentclass[12pt,a4paper,article]{memoir}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC
*** Org-crypt: Encrypt selected org-mode entries

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
(setq org-crypt-key nil)
#+END_SRC

*** org-reveal: Export slides for Reveal.js from orgmode

Load org-reveal to make slides with reveal.js

#+BEGIN_SRC emacs-lisp
(require 'ox-reveal)
#+END_SRC
*** Macro: toggle drawer visibility for this node
:PROPERTIES:
:DATE:     <2013-12-09 Mon 17:19>
:END:

See: http://stackoverflow.com/questions/5500035/set-custom-keybinding-for-specific-emacs-mode

#+BEGIN_SRC emacs-lisp
  (fset 'org-toggle-drawer
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([67108896 3 16 14 tab 24 24] 0 "%d")) arg)))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c M-d") 'org-toggle-drawer))
#+END_SRC

*** Toggle folding of current item (Command and keyboard command)

#+begin_src emacs-lisp :tangle yes
  (defun org-cycle-current-entry ()
    "toggle visibility of current entry from within the etnry."
    (interactive)
    (save-excursion)
    (outline-back-to-heading)
    (org-cycle))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-/") 'org-cycle-current-entry))
#+end_src

*** Keyboard Command Shortcut: Select heading of this node (for editing)

Note: outline-previous-heading (C-c p) places the point at the beginning of the heading line.  To edit the heading, one has to go past the * that mark the heading.  org-select heading places the mark at the beginning of the heading text and selects the heading, so one can start editing the heading right away.

#+BEGIN_SRC emacs-lisp
  (defun org-select-heading ()
    "Go to heading of current node, select heading."
    (interactive)
    (outline-previous-heading)
    (search-forward (plist-get (cadr (org-element-at-point)) :raw-value))
    (set-mark (point))
    (beginning-of-line)
    (search-forward " "))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-h") 'org-select-heading))
#+END_SRC
*** Encryption

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
(setq org-crypt-key nil)
#+END_SRC

*** Create menu for org-mode entries (lacarte lets you reach it from the keyboard, too)

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda () (imenu-add-to-menubar "Imenu")))
  (setq org-imenu-depth 3)
#+END_SRC

*** making icicle-imenu and icicle-occur work with org-mode

#+BEGIN_SRC emacs-lisp
  (defun org-icicle-occur ()
    "In org-mode, show entire buffer contents before running icicle-occur.
  Otherwise icicle-occur will not place cursor at found location,
  if the location is hidden."
    (interactive)
    (show-all)
    (icicle-occur (point-min) (point-max)))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-'") 'org-icicle-occur))

  (defun org-icicle-imenu ()
    "In org-mode, show entire buffer contents before running icicle-imenu.
  Otherwise icicle-occur will not place cursor at found location,
  if the location is hidden."
    (interactive)
    (show-all)
    (icicle-imenu (point-min) (point-max) t))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-=") 'org-icicle-imenu))

  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

*** Providing alternative to refile using icicles

#+BEGIN_SRC emacs-lisp
  (defun org-refile-icy (as-subtree)
    "Alternative to org-refile using icicles.
  Icicles seems to break org-modes headline buffer display, so one
  has to use icicles for all headline navigation if it is loaded.
  If quit with C-g, this function will have removed the section that
  is to be refiled.  To get it back, one has to undo, or paste."
    (interactive "P")
    (outline-back-to-heading)
    (org-cut-subtree)
    (show-all)
    (icicle-imenu (point-min) (point-max) t)
    (outline-next-heading)
    (unless (eq (current-column) 0) (insert "\n"))
    (org-paste-subtree)
    (if as-subtree (org-demote-subtree )))

  ;; Using key binding for org-reveal, since org-reveal
  ;; does nothing for me.
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-R") 'org-refile-icy))
#+END_SRC
** Add git repositories to Magit (git for emacs)

Magit config: Manage git repos from inside emacs

#+BEGIN_SRC emacs-lisp
(setq magit-repo-dirs
      '(
        "~/Dropbox/000WORKFILES/org"
        "~/Documents/Dev"
        "~/.emacs.d/personal"
))
#+END_SRC
