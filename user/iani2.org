* Generic Emacs Customization

** Theme: solarized-dark
#+BEGIN_SRC emacs-lisp
  (load-theme 'solarized-dark)
#+END_SRC
** Internationalization: Set Mac OS native fonts for japanese/greek
:PROPERTIES:
:DATE:     <2013-12-08 Sun 15:12>
:END:

Here is a solution that works fine for displaying Latin, Greek and Japanese texts in the same buffer.  The Menlo font displays Greek clearly and smoothly, and since it is a mono-space font, it also works well in tables.  The two lisp expressions have to be evaluated in the following order for this to work.

#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default"
                  'japanese-jisx0208
                  '("Hiragino Mincho Pro" . "iso10646-1"))
(set-fontset-font "fontset-default"
                  'greek
 ;; Note: iso10646-1 = Universal Character set (UCS)
 ;; It is compatible to Unicode, in its basic range
                  '("Menlo" . "iso10646-1"))
#+END_SRC

Links for further reading:

http://sunsite.univie.ac.at/textbooks/emacs/emacs_22.html#SEC203
http://www.gnu.org/software/emacs/manual/html_node/emacs/Modifying-Fontsets.html
For Greek see: http://iris.math.aegean.gr/~atsol/emacs-unicode/

** Maximize/toggle frame
#+BEGIN_SRC emacs-lisp
(maximize-frame) ;; maximize frame on startup
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
(tool-bar-mode -1)
#+END_SRC

** Generic Packages

*** Install el-get for installing of packages from github etc.

See: https://github.com/dimitri/el-get/blob/master/README.md

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/el-get/el-get")

  (unless (require 'el-get nil 'noerror)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.github.com/dimitri/el-get/master/el-get-install.el")
      (goto-char (point-max))
      (eval-print-last-sexp)))

  (add-to-list 'el-get-recipe-path "~/.emacs.d/el-get-user/recipes")
  (el-get 'sync)
#+END_SRC
*** Bring emacs-lisp up-to-date: dash.el

#+BEGIN_QUOTE
A modern list api for Emacs. No 'cl required.
#+END_QUOTE

See: https://github.com/magnars/dash.el#functions

Used in my packages as well as in projectile and other packages.

I load it here to have it available when experimenting with code.

#+BEGIN_SRC emacs-lisp
(require 'dash)
#+END_SRC

*** desktop

Save desktop between sessions.  To clear desktop: M-x desktop-clear

#+begin_src emacs-lisp :tangle yes
(desktop-save-mode 1)
#+end_src
*** Completion help: icicles, imenu+, auto-complete, ido

#+BEGIN_SRC emacs-lisp
  (require 'ido)
  (require 'imenu+)
  (require 'auto-complete)
  (ido-mode t)
  (icicle-mode)
  ;; (yas-global-mode) : interferes with auto-complete in emacs-lisp mode.
#+END_SRC
*** File-system navigation: projectile, helm

**** projectile

#+BEGIN_SRC emacs-lisp
  (setq projectile-completion-system 'grizzl)

  (defun projectile-dired-project-root ()
    "Dired root of current project.  Can be set as value of
  projectile-switch-project-action to dired root of project when switching.
  Note: projectile-find-dir (with grizzl) does not do this, but it
  asks to select a *subdir* of selected project to dired."
    (interactive)
    (dired (projectile-project-root)))

  (setq projectile-switch-project-action 'projectile-commander)

  (defun projectile-post-project ()
    "Which project am I actually in?"
    (interactive)
    (message (projectile-project-root)))

  (defun projectile-add-project ()
    "Add folder of current buffer's file to list of projectile projects"
    (interactive)
    (if (buffer-file-name (current-buffer))
        (projectile-add-known-project
         (file-name-directory (buffer-file-name (current-buffer))))))

  (global-set-key (kbd "H-p c") 'projectile-commander)
  (global-set-key (kbd "H-p h") 'helm-projectile)
  (global-set-key (kbd "H-p s") 'projectile-switch-project)
  (global-set-key (kbd "H-p d") 'projectile-find-dir)
  (global-set-key (kbd "H-p f") 'projectile-find-file)
  (global-set-key (kbd "H-p w") 'projectile-post-project)
  (global-set-key (kbd "H-p D") 'projectile-dired-project-root)
  (global-set-key (kbd "H-p +") 'projectile-add-project)
  (global-set-key (kbd "H-p -") 'projectile-remove-known-project)
  (global-set-key (kbd "H-p g") 'projectile-grep) ;; could not work it

#+END_SRC

**** helm

#+BEGIN_SRC emacs-lisp
  ;; must call these to initialize  helm-source-find-files

  (require 'helm-files) ;; (not auto-loaded by system!)
  (require 'helm-projectile)

  ;; Don't bicker if not in a project:
  (setq projectile-require-project-root)

  ;; Add add-to-projectile action after helm-find-files.
  (let ((find-files-action (assoc 'action helm-source-find-files)))
    (setcdr find-files-action
            (cons
             (cadr find-files-action)
             (cons '("Add to projectile" . helm-add-to-projectile)
                   (cddr find-files-action)))))

  ;; Use helm-find-files actions in helm-projectile
  (let ((projectile-files-action (assoc 'action helm-source-projectile-files-list)))
      (setcdr projectile-files-action (cdr (assoc 'action helm-source-find-files))))

  (defun helm-add-to-projectile (path)
    "Add directory of file to projectile projects.
  Used as helm action in helm-source-find-files"
    (projectile-add-known-project (file-name-directory path)))

  (global-set-key (kbd "H-h p") 'helm-projectile)
  (global-set-key (kbd "H-h g") 'helm-do-grep)
  (global-set-key (kbd "H-h f") 'helm-find-files)
  (global-set-key (kbd "H-h r") 'helm-resume)
  (global-set-key (kbd "H-h b") 'helm-bookmarks)
  (global-set-key (kbd "H-h l") 'helm-buffers-list)
  (global-set-key (kbd "H-M-h") 'helm-M-x)
  (global-set-key (kbd "H-h w") 'helm-world-time)

  (setq display-time-world-list
        '(("America/Los_Angeles" "Santa Barbara")
          ("America/New_York" "New York")
          ("Europe/London" "London")
          ("Europe/Lisbon" "Lisboa")
          ("Europe/Madrid" "Barcelona")
          ("Europe/Paris" "Paris")
          ("Europe/Berlin" "Berlin")
          ("Europe/Rome" "Rome")
          ;; ("Europe/Albania" "Gjirokastra") ;; what city to name here?
          ("Europe/Athens" "Athens")
          ("Asia/Calcutta" "Kolkatta")
          ("Asia/Jakarta" "Jakarta")
          ("Asia/Shanghai" "Shanghai")
          ("Asia/Tokyo" "Tokyo")))




#+END_SRC

#+BEGIN_SRC elisp
(message "%s" display-time-world-list)
#+END_SRC

#+RESULTS:
: ((America/Los_Angeles Seattle) (America/New_York New York) (Europe/London London) (Europe/Paris Paris) (Asia/Calcutta Bangalore) (Asia/Tokyo Tokyo))

*** Switch window

#+BEGIN_SRC emacs-lisp
  (require 'switch-window)
  (global-set-key (kbd "C-x o") 'switch-window)
#+END_SRC

*** Note on icicle key bindings and org-mode

C-c ' in org mode runs the command org-edit-special, for editing babel commands and other blocks.  To avoid conflict with icicles binding of the same key to icicle-occur, remap the latter to something else (e.g. C-c C-M-'), like this:
1. type M-x customize-group <RET> Icicles-Key-Bindings <RET>
2. Scroll down to Icicle Top Level Key Bindings, open the list, find icicle-occur, enter C-c C-M-' to the =Key:= field, go to top of buffer, use the =State= button to save this.

See also discussion here: http://www.emacswiki.org/emacs/Icicles_-_Key_Binding_Discussion
The relevant part is cited below:

#+BEGIN_QUOTE
But what is the best way to remove an internal value in the option `icicle-top-level-key-bindingsâ€™? It is a quite big list in its value. If I choose to remove that specific line through customize that variable, it would make my init file un-readable. So I need to write some function to make it in the runtime. Here is my function:
#+END_QUOTE

#+BEGIN_SRC elisp
  (eval-after-load "icicles-opt.el"
    (add-hook
     'icicle-mode-hook
     (lambda ()
       (setq my-icicle-top-level-key-bindings
             (mapcar (lambda (lst)
                       (unless (string= "icicle-occur" (nth 1 lst)) lst))
                     icicle-top-level-key-bindings))
       (setq icicle-top-level-key-bindings my-icicle-top-level-key-bindings) )))

;;  (icy-mode)
#+END_SRC

#+BEGIN_QUOTE
DavidYoung
#+END_QUOTE

*** lacarte: select menu items from the keyboard (good for org-mode with imenu)

#+BEGIN_SRC emacs-lisp
(require 'lacarte)
(global-set-key [?\e ?\M-x] 'lacarte-execute-command)
#+END_SRC

*** Buffer-move, windmove, buffer switching

- windmove (package) :: Use cursor keys to switch cursor position between windows.  Bound to =control-super-<cursorkey>=.
- buffer-move (package) :: Use cursor keys to switch buffer position between windows.  Bound to =fn-shift-<cursor key>=.
- next-buffer, previous-buffer (built-in commands) :: Use cursor keys to switch to previous/next buffer in same window.  Bound to =function-super-<cursor key>=

#+BEGIN_SRC emacs-lisp

  (global-set-key (kbd "<C-s-up>") 'windmove-up)
  (global-set-key (kbd "<C-s-down>") 'windmove-down)
  (global-set-key (kbd "<C-s-right>") 'windmove-right)
  (global-set-key (kbd "<C-s-left>") 'windmove-left)

  (require 'buffer-move)
  (global-set-key (kbd "<S-prior>") 'buf-move-up)
  (global-set-key (kbd "<S-next>") 'buf-move-down)
  (global-set-key (kbd "<S-end>") 'buf-move-right)
  (global-set-key (kbd "<S-home>") 'buf-move-left)

  (global-set-key (kbd "<s-home>") 'previous-buffer)
  (global-set-key (kbd "<s-end>") 'next-buffer)
#+END_SRC

*** Ido-imenu command and jump back after completion, by Magnar Sveen, and others.

Disabled.

#+BEGIN_SRC elisp
  ;;; ido-imenu
  (defun ido-imenu ()
    "Update the imenu index and then use ido to select a symbol to navigate to.
  Symbols matching the text at point are put first in the completion list."
    (interactive)
    (imenu--make-index-alist)
    (let ((name-and-pos '())
          (symbol-names '()))
      (flet ((addsymbols
            (symbol-liost)
            (when (listp symbol-list)
              (dolist (symbol symbol-list)
                (let ((name nil) (position nil))
                  (cond
                   ((and (listp symbol) (imenu--subalist-p symbol))
                    (addsymbols symbol))

                   ((listp symbol)
                    (setq name (car symbol))
                    (setq position (cdr symbol)))

                   ((stringp symbol)
                    (setq name symbol)
                    (setq position
                          (get-text-property 1 'org-imenu-marker symbol))))

                  (unless (or (null position) (null name))
                    (add-to-list 'symbol-names name)
                    (add-to-list 'name-and-pos (cons name position))))))))
        (addsymbols imenu--index-alist))
  ;; If there are matching symbols at point, put them at the beginning of `symbol-names'.
      (let ((symbol-at-point (thing-at-point 'symbol)))
        (when symbol-at-point
          (let* ((regexp (concat (regexp-quote symbol-at-point) "$"))
                 (matching-symbols
                  (delq nil (mapcar (lambda (symbol)
                                      (if (string-match regexp symbol) symbol))
                                    symbol-names))))
            (when matching-symbols
              (sort matching-symbols (lambda (a b) (> (length a) (length b))))
              (mapc
               (lambda (symbol)
                 (setq symbol-names (cons symbol (delete symbol symbol-names))))
               matching-symbols)))))
      (let* ((selected-symbol (ido-completing-read "Symbol? " symbol-names))
             (position (cdr (assoc selected-symbol name-and-pos))))
        (goto-char position))))

  ;; Push mark when using ido-imenu

  (defvar push-mark-before-goto-char nil)

  (defadvice goto-char (before push-mark-first activate)
    (when push-mark-before-goto-char
      (push-mark)))

  (defun ido-imenu-push-mark ()
    (interactive)
    (let ((push-mark-before-goto-char t))
      (ido-imenu)))
#+END_SRC

#+RESULTS:
: ido-imenu-push-mark

*** smex (auto-complete minibuffer commands called with Meta-x)

#+BEGIN_SRC emacs-lisp
;; Smex: Autocomplete meta-x command
(global-set-key [(meta x)]
                (lambda ()
                  (interactive)
                  (or (boundp 'smex-cache)
                      (smex-initialize))
                  (global-set-key [(meta x)] 'smex)
                  (smex)))

(global-set-key [(shift meta x)]
                (lambda ()
                  (interactive)
                  (or (boundp 'smex-cache)
                      (smex-initialize))
                  (global-set-key [(shift meta x)] 'smex-major-mode-commands)
                  (smex-major-mode-commands)))
#+END_SRC

*** Multiple Cursors

#+BEGIN_SRC emacs-lisp
  (require 'multiple-cursors)
  (global-set-key (kbd "C-c m") 'helm-mini)
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-M->") 'mc/mark-more-like-this-extended)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
  ;; (global-set-key (kbd "C->") 'mc/mark-next-symbol-like-this)
  ;; (global-set-key (kbd "C->") 'mc/mark-next-word-like-this)

#+END_SRC

*** Whitespace Mode

#+BEGIN_SRC emacs-lisp
  (defun turn-off-whitespace-mode () (whitespace-mode -1))
  (defun turn-on-whitespace-mode () (whitespace-mode 1))
#+END_SRC

*** Key Chords

#+BEGIN_SRC emacs-lisp
  (require 'key-chord)
  (key-chord-mode 1)

  (defun paren-sexp ()
    (interactive)
    (insert "(")
    (forward-sexp)
    (insert ")"))

  (defun code-quote-sexp ()
    (interactive)
    (insert "=")
    (forward-sexp)
    (insert "="))

  (key-chord-define-global "jk"     'ace-jump-char-mode)
  (key-chord-define-global "jj"     'ace-jump-word-mode)
  (key-chord-define-global "jl"     'ace-jump-line-mode)

  (key-chord-define-global "hj"     'undo)

  (key-chord-define-global "{}"     "{   }\C-b\C-b\C-b")
  (key-chord-define-global "()"     'paren-sexp)
  (key-chord-define-global "(_"     "()\C-b")
  (key-chord-define-global "=="     'code-quote-sexp)

  ;; Exit auto-complete, keeping the current selection,
  ;; while avoiding possible side-effects of TAB or RETURN.
  (key-chord-define-global "KK"      "\C-f\C-b")
  ;; Trick for triggering yasnippet when using in tandem with auto-complete:
  ;; Move forward once to get out of auto-complete, then backward once to
  ;; end of keyword, and enter tab to trigger yasnippet.
  (key-chord-define-global "KL"      "\C-f\C-b\C-i")

  ;; Jump to any symbol in buffer using ido-imenu
  (key-chord-define-global "KJ"      'ido-imenu)
#+END_SRC

*** hl-sexp mode (also: highlight-sexps)

Highlight expressions enclosed by (), {} or [] in code.

There exist 2 versions:

1. hl-sexp package available from elpa.
   Package name: hl-sexp
   Mode name: hl-sexp-mode
2. highlight-sexps.el, from http://www.emacswiki.org/emacs/HighlightSexp.
   Package name: highlight-sexps
   Mode name: highlight-sexps-mode

highlight-sexps.el looks nicer, because it highlights both the innermost s-expression and the one enclosing it, and it does not un-highlight the line where the cursor is on.  But it sometimes stops working.  So I use hl-sexp

#+BEGIN_SRC emacslisp
  (require 'hl-sexp)
  ;; (require 'highlight-sexps)
  ;; Include color customization for dark color theme here.
  (custom-set-variables
   '(hl-sexp-background-colors (quote ("gray0"  "#0f003f"))))
#+END_SRC

*** Directory/Buffer navigation: Dired+, Dirtree, Speedbar
**** Dired+, Dirtree, Speedbar

Note about dirtree:  Very handy.  There are several versions out there, and there is also a different package under the same name.  No all versions work.  The one that works for me all the time is: https://github.com/rtircher/dirtree.  I installed it manually.

#+BEGIN_SRC emacs-lisp
  (require 'dired+)
  (require 'dirtree)
  (global-set-key (kbd "H-d d") 'dirtree)
  (require 'sr-speedbar)
  (global-set-key (kbd "H-d s") 'sr-speedbar-toggle)
#+END_SRC

**** Dired customization from Healy's startup kit
(From Healy's startup kit)

Note: Perhaps these are not used.  Need to test.

***** Open pdf files with default macos app in dired
:PROPERTIES:
:DATE:     <2013-12-01 Sun 15:01>
:END:

From: http://stackoverflow.com/questions/20019732/define-keybinding-for-dired-to-run-a-command-open-on-the-file-under-the-cur

#+BEGIN_SRC emacs-lisp
  (define-key dired-mode-map (kbd "<SPC>")
    (lambda () (interactive)
      (let ((lawlist-filename (dired-get-file-for-visit)))
        (if (equal (file-name-extension lawlist-filename) "pdf")
            (start-process "default-pdf-app" nil "open" lawlist-filename)))))
#+END_SRC
***** Dired
****** TODO Copy folder / file path from DIRED

****** TODO Open home folder in finder

****** TODO Open selected folder or file in finder

****** Dired-x
Dired extensions
#+SOURCE: Dired-x
#+BEGIN_SRC emacs-lisp
  (load "dired-x")
#+END_SRC

#+RESULTS:
: t

****** Dired open multiple files
In dired mode, visit all marked files using. Bound to the "F" key.
#+SOURCE: dired-F
#+BEGIN_SRC emacs-lisp
  (eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "F" 'my-dired-find-file)
     (defun my-dired-find-file (&optional arg)
       "Open each of the marked files, or the file under the point, or when prefix arg, the next N files "
       (interactive "P")
       (let* ((fn-list (dired-get-marked-files nil arg)))
         (mapc 'find-file fn-list)))))
#+END_SRC

#+RESULTS:
: my-dired-find-file

****** Stripe Dired buffers
#+name: stripe-dired
#+begin_src [emacs-lisp (This part is disabled)]
(require 'stripe-buffer)
(add-hook 'org-mode-hook 'org-table-stripes-enable)
(add-hook 'dired-mode-hook 'stripe-listify-buffer)
#+end_src

*** TODO Fixme minor mode?

http://www.emacswiki.org/emacs/FixmeMode
http://www.emacswiki.org/emacs/fixme-mode.el

Or see: hl-todo, and further packages like it, listed in hl-todo Help file:

- [[http://emacswiki.org/fic-ext-mode.el][fic-ext-mode]]
- [[https://github.com/lewang/fic-mode][fic-mode]]
- [[http://emacswiki.org/FixmeMode][fixme-mode]]
- [[https://github.com/rolandwalker/fixmee][fixmee]]
- see http://emacswiki.org/FixmeMode for more alternatives

If you like this you might also like [[https://github.com/tarsius/orglink][orglink]].
*** Mac-OS extension: Open file in finder

From: http://stackoverflow.com/questions/20510333/in-emacs-how-to-show-current-file-in-finder

#+BEGIN_SRC emacs-lisp
  (defun open-finder ()
    (interactive)
    ;; IZ Dec 25, 2013 (3:25 PM): Making this work in dired:
    (if (equal major-mode 'dired-mode)
        (open-finder-dired)
        (let ((path
               (if (equal major-mode 'dired-mode)
                   (file-truename (dired-file-name-at-point))
                 (buffer-file-name)))
              dir file)
          (when path
            (setq dir (file-name-directory path))
            (setq file (file-name-nondirectory path))
            (open-finder-1 dir file)))))

  (defun open-finder-1 (dir file)
    (message "open-finder-1 dir: %s\nfile: %s" dir file)
    (let ((script
           (if file
               (concat
                "tell application \"Finder\"\n"
                " set frontmost to true\n"
                " make new Finder window to (POSIX file \"" dir "\")\n"
                " select file \"" file "\"\n"
                "end tell\n")
             (concat
              "tell application \"Finder\"\n"
              " set frontmost to true\n"
              " make new Finder window to {path to desktop folder}\n"
              "end tell\n"))))
      (start-process "osascript-getinfo" nil "osascript" "-e" script)))

#+END_SRC
* Customization of Specific Authoring Modes
** SuperCollider
*** Sclang Setup
#+BEGIN_SRC emacs-lisp
;;; Directory of SuperCollider support, for quarks, plugins, help etc.
(defvar sc_userAppSupportDir
  (expand-file-name "~/Library/Application Support/SuperCollider"))

;; Make path of sclang executable available to emacs shell load path
(add-to-list
 'exec-path
 "/Applications/SuperCollider/SuperCollider.app/Contents/Resources/")

;; Global keyboard shortcut for starting sclang
(global-set-key (kbd "C-c M-s") 'sclang-start)
;; overrides alt-meta switch command
(global-set-key (kbd "C-c W") 'sclang-switch-to-workspace)

;; Disable switching to default SuperCollider Workspace when recompiling SClang
(setq sclang-show-workspace-on-startup nil)

;; Save results of sc evaluation in elisp variable for access in emacs
(defvar sclang-return-string  nil
  "The string returned by sclang process after evaluating expressions.")

(defadvice sclang-process-filter (before provide-sclang-eval-results)
  "Pass sc eval return string to elisp by setting sclang-return-string variable."
  (setq sclang-return-string (ad-get-arg 1)))

(ad-activate 'sclang-process-filter)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'sclang)
#+END_SRC

*** SuperCollider-specific minor modes

Paredit mode breaks re-starting sclang! Therefore, do not use it. Paredit-style bracket movement commands d, u, f, b, n, p work in sclang-mode without loading Paredit.

Sclang-extensions-mode possibly breaks sclang-ac-mode.  Therefore not trying it out for now.

#+BEGIN_SRC emacs-lisp
  ;; paredit mode breaks re-starting sclang! Therefore, do not use it.
  ;; Note: Paredit-style bracket movement commands d, u, f, b, n, p work
  ;; in sclang-mode without loading Paredit.
  ;; (add-hook 'sclang-mode-hook 'paredit-mode)
  (add-hook 'sclang-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'sclang-mode-hook 'hl-sexp-mode)
  (add-hook 'sclang-mode-hook 'sclang-ac-mode)
  ;; Following possibly breaks auto-complete in my setup:  Disabled for now.
  ;; (add-hook 'sclang-mode-hook 'sclang-extensions-mode)
#+END_SRC

*** Sclang keyboard shortcuts

#+BEGIN_SRC emacs-lisp
;; Global keyboard shortcut for starting sclang
(global-set-key (kbd "C-c M-s") 'sclang-start)
;; Show workspace
(global-set-key (kbd "C-c C-M-w") 'sclang-switch-to-workspace)
#+END_SRC
** emacs-lisp
#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'emacs-lisp-mode-hook 'hl-sexp-mode)
  (add-hook 'emacs-lisp-mode-hook 'hl-sexp-mode)
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode)
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-whitespace-mode)
  (add-hook 'emacs-lisp-mode-hook 'auto-complete-mode)
  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  #+END_SRC

** org-mode
*** Use visual line, whitespace and windmove in org-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'visual-line-mode)
  (add-hook 'org-mode-hook 'turn-off-whitespace-mode)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)
#+END_SRC

*** Customize Org-mode display

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t) ;; auto-indent text in subtrees
  (setq org-hide-leading-stars t) ;; hide leading stars in subtree headings
  (setq org-src-fontify-natively t) ;; colorize source-code blocks natively
#+END_SRC

*** Global key for org-agenda: C-c a
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-ca" 'org-agenda)
#+END_SRC

*** Calendar framework: Show org agenda in iCal-style layout

#+BEGIN_SRC emacs-lisp
 (require 'calfw-org)
#+END_SRC

*** Global key for cfw org calendar framework): C-c M-a

#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-c\M-a" 'cfw:open-org-calendar)
  (global-set-key "\C-c\C-xm" 'org-mark-ring-goto)
#+END_SRC

*** Insert DATE property with current time
:PROPERTIES:
:DATE:     <2014-01-02 Thu 13:35>
:END:

#+BEGIN_SRC emacs-lisp

  (defun org-set-date (&optional inactive property)
    "Set DATE property with current time.  Active timestamp."
    (interactive "P")
    (org-set-property
     (if property property "DATE")
     (let ((stamp (format-time-string (cdr org-time-stamp-formats) (current-time))))
       (if inactive
           (concat "[" (substring stamp 1 -1) "]")
         stamp))))

  ;; Note: This keybinding is in analogy to the standard keybinding:
  ;; C-c . -> org-time-stamp
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-.") 'org-set-date))
#+END_SRC

*** Set DUE property with selected time/date

#+BEGIN_SRC elisp
  (defun org-set-due-property ()
    (interactive)
    (org-set-property
     "DUE"
     (format-time-string (cdr org-time-stamp-formats) (org-read-date t t))))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c M-.") 'org-set-due-property))
#+END_SRC
*** Log: (simplified alternative to capture)
:PROPERTIES:
:DATE:     <2013-12-07 Sat 21:59>
:ID:       1E0A70E5-7417-48E7-B17A-9C727D995AE4
:END:

Time tasks and keep log file, in a very short way

- Very simple and fast input mechanism
- New task simply also sets the timestamp for the end of the previous one.
- Following properties are set:
  START_TIME (= active timestamp set at time of start)
  END_TIME (= active timestamp set at time of start of next log entry)
  TIME_SPAN (= START_TIME--END_TIME as timestamps)
  DURATION (= START_TIME-END_TIME as hours:minutes)
- Keeps current task in file "stopwatch.txt"
  This is read by geeklet CountUp, to display duration of current task.
  (sh code of geeklet is included below).

**** CountUp geeklet code

#+BEGIN_SRC sh
#!/bin/bash
# Homework countdown
# BETA - I will update this when I get more time
function countdown
{
	CURRENT=$(date -j -f %D_%T $1 +%s)
	TARGET=$(date +%s)
	LEFT=$((TARGET-CURRENT))
	WEEKS=$((LEFT/604800))
	DAYS=$(( (LEFT%604800)/86400))
	HOURS=$(( (LEFT%86400)/3600))
	MINS=$(( (LEFT%3600)/60))
	SECS=$((LEFT%60))

	lblWEEKS="Weeks"
	lblDAYS="Days"

	if [ $DAYS == 1 ]
	then
	lblDAYS="Day"
	fi

	if [ $WEEKS == 1 ]
	then
	lblWEEKS="Weeky"
	fi

	if [ $HOURS -lt 10 ]
	then
		HOURS=0$HOURS
	fi

	if [ $MINS -lt 10 ]
	then
		MINS=0$MINS
	fi


	if [ $SECS -lt 10 ]
	then
		SECS=0$SECS
	fi


	echo $2 $HOURS:$MINS:$SECS
	# Optional extra line between timers
	# echo
}
DATES=( $( cat /Users/iani2/Dropbox/000WORKFILES/org/monitoring/stopwatch.txt ) )
# Even numbered indices are names, odd numbered indices are dates

if [ ${#DATES[@]} == 0 ]
then
echo "No Deadlines!"
return
fi

for (( i = 0 ; i < ${#DATES[@]} ; i+=2 ))
do
countdown ${DATES[i+1]} ${DATES[i]}
done
#+END_SRC

**** Emacs-lisp log function

#+BEGIN_SRC emacs-lisp
  (defun log (expense)
    "Write countdown file for countdown geeklet.
    Ask user number of seconds to plan countdown in future."
    (interactive "P")

    (let* ((topic (completing-read "Enter topic: " '("Mtg" "Expense" "Note")))
          (timer-string
           (concat
            (replace-regexp-in-string " " "_" topic)
            (format-time-string ": %D_%T" (current-time)))))
      (if (< (length topic) 1) (setq topic "Untitled task"))
      (find-file
       "/Users/iani2/Dropbox/000WORKFILES/org/monitoring/stopwatch.txt")
  ;;    (beginning-of-buffer)
  ;;    (kill-line)
      (erase-buffer)
      (insert timer-string)
      (save-buffer)
      (message (concat "Now timing: " timer-string))
      (find-file
       "/Users/iani2/Dropbox/000WORKFILES/org/monitoring/log.org")
      (widen)
      (end-of-buffer)
      (if (> (org-outline-level) 1) (outline-up-heading 100 t))
      (org-set-date t "END_TIME")
      (org-set-property
       "TIMER_SPAN"
       (concat
        (replace-regexp-in-string
         ">" "]"
         (replace-regexp-in-string "<" "[" (org-entry-get (point) "START_TIME")))
        "--"
        (org-entry-get (point) "END_TIME")))
      (let* ((seconds
              (-
               (org-float-time
                (apply
                 'encode-time
                 (org-parse-time-string (org-entry-get (point) "END_TIME"))))
               (org-float-time
                (apply
                 'encode-time
                 (org-parse-time-string (org-entry-get (point) "START_TIME"))))
               ))
             (hours (floor (/ seconds 3600)))
             (seconds (- seconds (* 3600 hours)))
             (minutes (floor (/ seconds 60))))
        (org-set-property
         "DURATION"
         (replace-regexp-in-string " " "0" (format "%2d:%2d" hours minutes))))
      (end-of-buffer)
      (insert-string "\n* ")
      (insert-string (replace-regexp-in-string "_" " " timer-string))
      ;;      (insert-string "\n")
      (org-set-date nil "START_TIME")
      (org-set-date t) ;; also set DATE property: for blog entries
      (org-id-get-create)
      (when expense
        (org-set-tags-to '("expense"))
        (org-set-property "EXPENSE" nil))
      (org-set-tags-command)
  ;;    (if narrow-p
      (org-narrow-to-subtree)
      (goto-char (point-max))
      (org-show-subtree)
      (org-show-entry)
      (save-buffer)
  ;;    )
      ))

  (global-set-key (kbd "C-M-l") 'log)
#+END_SRC

*** Org-Babel
**** Org-Babel: enable some languages

Enable some cool languages in org-babel mode.

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (sh . t)
   (ruby . t)
   (python . t)
   (perl . t)
   ))
#+END_SRC
**** Org-Babel: load current file

#+BEGIN_SRC emacs-lisp
  (defun org-babel-load-current-file ()
    (interactive)
    (org-babel-load-file (buffer-file-name (current-buffer))))

  ;; Note: Overriding default key binding to provide consistent pattern:
  ;; C-c C-v f -> tangle, C-c C-v C-f -> load
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-v C-f") 'org-babel-load-current-file))
#+END_SRC

#+RESULTS:
: org-babel-load-current-file

*** Orgmode latex customization

#+BEGIN_SRC emacs-lisp
;;; Load latex package
(require 'ox-latex)

;;; Use xelatex instead of pdflatex, for support of multilingual fonts (Greek etc.)
(setq org-latex-pdf-process (list "xelatex -interaction nonstopmode -output-directory %o %f" "xelatex -interaction nonstopmode -output-directory %o %f" "xelatex -interaction nonstopmode -output-directory %o %f"))

;;; Add beamer to available latex classes, for slide-presentaton format
(add-to-list 'org-latex-classes
             '("beamer"
               "\\documentclass\[presentation\]\{beamer\}"
               ("\\section\{%s\}" . "\\section*\{%s\}")
               ("\\subsection\{%s\}" . "\\subsection*\{%s\}")
               ("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")))

;;; Add memoir class (experimental)
(add-to-list 'org-latex-classes
             '("memoir"
               "\\documentclass[12pt,a4paper,article]{memoir}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC
*** Org-crypt: Encrypt selected org-mode entries

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
(setq org-crypt-key nil)
#+END_SRC

*** org-reveal: Export slides for Reveal.js from orgmode

Load org-reveal to make slides with reveal.js

#+BEGIN_SRC emacs-lisp
(require 'ox-reveal)
#+END_SRC
*** Macro: toggle drawer visibility for this node
:PROPERTIES:
:DATE:     <2013-12-09 Mon 17:19>
:END:

See: http://stackoverflow.com/questions/5500035/set-custom-keybinding-for-specific-emacs-mode

#+BEGIN_SRC emacs-lisp
  (fset 'org-toggle-drawer
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([67108896 3 16 14 tab 24 24] 0 "%d")) arg)))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c M-d") 'org-toggle-drawer))
#+END_SRC

*** Toggle folding of current item (Command and keyboard command)

#+begin_src emacs-lisp :tangle yes
  (defun org-cycle-current-entry ()
    "toggle visibility of current entry from within the etnry."
    (interactive)
    (save-excursion)
    (outline-back-to-heading)
    (org-cycle))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-/") 'org-cycle-current-entry))
#+end_src

*** Keyboard Command Shortcut: Select heading of this node (for editing)

Note: outline-previous-heading (C-c p) places the point at the beginning of the heading line.  To edit the heading, one has to go past the * that mark the heading.  org-select heading places the mark at the beginning of the heading text and selects the heading, so one can start editing the heading right away.

#+BEGIN_SRC emacs-lisp
  (defun org-select-heading ()
    "Go to heading of current node, select heading."
    (interactive)
    (outline-previous-heading)
    (search-forward (plist-get (cadr (org-element-at-point)) :raw-value))
    (set-mark (point))
    (beginning-of-line)
    (search-forward " "))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-h") 'org-select-heading))
#+END_SRC
*** Encryption

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;; GPG key to use for encryption
;; Either the Key ID or set to nil to use symmetric encryption.
(setq org-crypt-key nil)
#+END_SRC

*** Create menu for org-mode entries (lacarte lets you reach it from the keyboard, too)

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook
            (lambda () (imenu-add-to-menubar "Imenu")))
  (setq org-imenu-depth 3)
#+END_SRC

*** Working with icicles in org-mode

**** making icicle-imenu and icicle-occur work with org-mode

#+BEGIN_SRC emacs-lisp
  (defun org-icicle-occur ()
    "In org-mode, show entire buffer contents before running icicle-occur.
   Otherwise icicle-occur will not place cursor at found location,
   if the location is hidden."
    (interactive)
    (show-all)
    (icicle-occur (point-min) (point-max)))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-'") 'org-icicle-occur))
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c i o") 'org-icicle-occur))
  (defun org-icicle-imenu ()
    "In org-mode, show entire buffer contents before running icicle-imenu.
   Otherwise icicle-occur will not place cursor at found location,
   if the location is hidden."
    (interactive)
    (show-all)
    (icicle-imenu (point-min) (point-max) t))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-=") 'org-icicle-imenu))
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c i m") 'org-icicle-imenu))

  ;; install alternative for org-mode C-c = org-table-eval-formula
  ;; which is stubbornly overwritten by icy-mode.
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c C-x =") 'org-table-eval-formula))

  ;; this is a redundant second try for the above, to be removed after testing:
  (add-hook 'org-mode-hook
            (lambda ()
              (local-set-key (kbd "C-c M-=") 'org-table-eval-formula)))

  ;;; ???? Adapt org-mode to icicle menus when refiling (C-c C-w)
  ;;; Still problems. Cannot use standard org refiling with icicles activated!
  (setq org-outline-path-complete-in-steps nil)
#+END_SRC

**** Definitely switch prelude off in org mode, as it totally screws-up key bindings

Especially in the case of Meta-shift-up and Meta-shift-down for spreadsheets.
Have not figured out yet how to override those keys specifically.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda () (prelude-mode -1)))
#+END_SRC


**** Providing alternatives for refile and copy using icicles

#+BEGIN_SRC emacs-lisp
  (defun org-refile-icy (as-subtree &optional do-copy-p)
    "Alternative to org-refile using icicles.
  Refile or copy current section, to a location in the file selected with icicles.
  Without prefix argument: Place the copied/cut section it *after* the selected section.
  With prefix argument: Make the copied/cut section *a subtree* of the selected section.

  Note 1: If quit with C-g, this function will have removed the section that
  is to be refiled.  To get it back, one has to undo, or paste.

  Note 2: Reason for this function is that icicles seems to break org-modes headline
  buffer display, so onehas to use icicles for all headline navigation if it is loaded."
    (interactive "P")
    (outline-back-to-heading)
    (if do-copy-p (org-copy-subtree) (org-cut-subtree))
    (show-all)
    (icicle-imenu (point-min) (point-max) t)
    (outline-next-heading)
    (unless (eq (current-column) 0) (insert "\n"))
    (org-paste-subtree)
    (if as-subtree (org-demote-subtree)))

  (defun org-copy-icy (as-subtree)
    "Copy section to another location in file, selecting the location with icicles.
  See org-refile-icy."
    (interactive "P")
    (org-refile-icy as-subtree t))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c i r") 'org-refile-icy))
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c i c") 'org-copy-icy))
#+END_SRC

*** Property shortcuts for collaboration: From-To

Note: searchable both with org-mode match: C-c / p and with icicles search,
org-icicle-occur or icicle-occur, here: C-c C-'

#+BEGIN_SRC emacs-lisp
  (defun org-from ()
    "Set property 'FROM'."
    (interactive)
    (org-set-property "FROM" (ido-completing-read "From whom? " '("ab" "iz"))))

  (defun org-to ()
    "Set property 'TO'."
    (interactive)
    (org-set-property "TO" (ido-completing-read "To whom? " '("ab" "iz"))))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c x f") 'org-from))
  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c x t") 'org-to))
#+END_SRC

*** fname-find-file-standardized: Consistent multi-component filenames

#+BEGIN_SRC emacs-lisp
  (defvar fname-parts-1-2 nil)
  (defvar fname-part-3 nil)
  (defvar fname-root "~/Dropbox/000Workfiles/2014/")
  (defvar fname-filename-components
    (concat fname-root  "00000fname-filename-components.org"))
  (defun fname-find-file-standardized ()
    (interactive)
    (unless fname-part-3 (fname-load-file-components))
    (setq *grizzl-read-max-results* 40)
    (let* ((root fname-root)
           (index-1 (grizzl-make-index
                     (mapcar 'car fname-parts-1-2)))
           (name-1 (grizzl-completing-read "Part 1: " index-1))
           (index-2 (grizzl-make-index (cdr (assoc name-1 fname-parts-1-2))))
           (name-2 (grizzl-completing-read "Part 2: " index-2))
           (index-3 (grizzl-make-index fname-part-3))
           (name-3 (grizzl-completing-read "Part 3: " index-3))
           (path (concat root name-1 "_" name-2 "_" name-3 "_"))
           (candidates (file-expand-wildcards (concat path "*")))
           extension-index extension final-choice)
      (setq final-choice
            (completing-read "Choose file or enter last component: " candidates))
      (cond ((string-match (concat "^" path) final-choice)
             (setq path final-choice))
        (t
         (setq extension (ido-completing-read
                          "Enter extension:" '("org" "el" "html" "scd" "sc" "ck")))
         (setq path (concat path final-choice
                            (format-time-string "_%Y-%m-%d-%H-%M" (current-time))
                            "." extension))))
      (find-file path)
      (set-visited-file-name
       (replace-regexp-in-string
        "_[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}-[0-9]\\{2\\}-[0-9]\\{2\\}"
        (format-time-string "_%Y-%m-%d-%H-%M" (current-time)) path))))

  (defun fname-load-file-components ()
    (interactive)
    (let ((buffer (find-file fname-filename-components)))
      (set-buffer buffer)
      (save-excursion
        (let ((levels1_2-section (car (org-map-entries '(point) "LEVELS1_2")))
              (level3-section (car (org-map-entries '(point) "LEVEL3")))
              level3 level)
          (setq fname-parts-1-2 '(1))
          (goto-char levels1_2-section)
          (save-restriction
            (org-narrow-to-subtree)
            (org-map-entries
             (lambda ()
               (setq level (plist-get (cadr (org-element-at-point)) :level))
               (cond
                ((equal 2 level)
                 (setq last (list (org-get-heading)))
                 (setcdr (last fname-parts-1-2) (list last)))
                ((equal 3 level)
                 (setcdr (last last) (list (org-get-heading)))))))
            (setq fname-parts-1-2 (cdr fname-parts-1-2)))
          (goto-char level3-section)
          (save-restriction
            (setq fname-part-3 '(1))
            (org-narrow-to-subtree)
            (org-map-entries
             (lambda ()
               (setq level (plist-get (cadr (org-element-at-point)) :level))
               (cond
                ((equal 2 level)
                 (setq last (org-get-heading))
                 (setcdr (last fname-part-3) (list last))))))
            (setq fname-part-3 (cdr fname-part-3)))))
      (kill-buffer buffer))
    (message "file component list updated"))

    (defun fname-edit-file-components ()
    (interactive)
    (find-file fname-filename-components))

    (defun fname-menu ()
    (interactive)
    (let ((action (ido-completing-read
                   "Choose action: "
                   '("fname-edit-file-components"
                    "fname-load-file-components"
                    "fname-find-file-standardized"))))
      (funcall (intern action))))

  (global-set-key (kbd "H-f f") 'fname-find-file-standardized)
  (global-set-key (kbd "H-f m") 'fname-menu)
  (global-set-key (kbd "H-f e") 'fname-edit-file-components)
  (global-set-key (kbd "H-f l") 'fname-load-file-components)

#+END_SRC

#+RESULTS:
: fname-find-file-standardized


** Add git repositories to Magit (git for emacs)

Magit config: Manage git repos from inside emacs

#+BEGIN_SRC emacs-lisp
(setq magit-repo-dirs
      '(
        "~/Dropbox/000WORKFILES/org"
        "~/Documents/Dev"
        "~/.emacs.d/personal"
))
#+END_SRC
** Macro: toggle drawer visibility for this node
:PROPERTIES:
:DATE:     <2013-12-09 Mon 17:19>
:END:

See: http://stackoverflow.com/questions/5500035/set-custom-keybinding-for-specific-emacs-mode

#+BEGIN_SRC emacs-lisp
  (fset 'org-toggle-drawer
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([67108896 3 16 14 tab 24 24] 0 "%d")) arg)))

  (eval-after-load 'org
    '(define-key org-mode-map (kbd "C-c M-d") 'org-toggle-drawer))
#+END_SRC
